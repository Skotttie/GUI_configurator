<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Modell Viewer</title>
  <link rel="stylesheet" href="style.css">
  <style>
    body { margin:0; overflow:hidden; font-family: sans-serif; }
    #viewer { width: 100%; height: 70vh; display:block; background: #f6f6f6; }
    .controls { padding: 10px; background: #eee; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    label { font-size: 14px; }
    select, button { font-size: 14px; padding: 2px 6px; }
    #debug { font-size: 12px; color: #333; padding:5px; white-space: pre-line; max-height:150px; overflow:auto; background:#fafafa; }
  </style>
</head>
<body>

<div class="controls">
  <label>Modell:
    <select id="modell">
      <option value="d21047729_angepasst.glb">d21047729_angepasst.glb</option>
      <!-- weitere Modelle hier -->
    </select>
  </label>

  <label>Farbe:
    <select id="farbe">
      <option value="#cccccc">Grau</option>
      <option value="#000000">Schwarz</option>
      <option value="#ffffff">Weiß</option>
      <option value="#c0a060">Beige</option>
    </select>
  </label>

  <button id="reloadBtn">Neu laden</button>
</div>

<div id="viewer"></div>
<div id="debug" aria-live="polite"></div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

const dbgEl = document.getElementById('debug');
const dbg = (msg) => {
  console.log(msg);
  dbgEl.innerText = msg + "\n" + dbgEl.innerText;
};

// Szene, Kamera, Renderer
const container = document.getElementById('viewer');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf6f6f6);

const camera = new THREE.PerspectiveCamera(60, container.clientWidth/container.clientHeight, 0.01, 1000);
camera.position.set(0,1,3);

const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setSize(container.clientWidth, container.clientHeight);
container.appendChild(renderer.domElement);

// Licht
const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.8);
dir.position.set(3,10,5);
scene.add(dir);

// Controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.07;

// Testwürfel
let testCube = new THREE.Mesh(
  new THREE.BoxGeometry(0.3,0.3,0.3),
  new THREE.MeshStandardMaterial({color:0x22aa22})
);
testCube.position.set(0,0.15,0);
scene.add(testCube);

let currentModel = null;
const loader = new GLTFLoader();

// Funktion zum Ausrichten der Kamera
function fitCameraToObject(camera, object, controls, offset=1.25){
  const box = new THREE.Box3().setFromObject(object);
  const size = box.getSize(new THREE.Vector3());
  const center = box.getCenter(new THREE.Vector3());

  const maxDim = Math.max(size.x,size.y,size.z);
  const fov = camera.fov * (Math.PI/180);
  let cameraZ = Math.abs(maxDim / (2*Math.tan(fov/2)));
  cameraZ *= offset;

  camera.position.copy(center);
  camera.position.z += cameraZ;
  camera.position.y = center.y + (maxDim*0.1);
  camera.near = maxDim/100;
  camera.far = cameraZ*100;
  camera.updateProjectionMatrix();

  if(controls){
    controls.target.copy(center);
    controls.update();
  }
}

// Modell laden
async function loadModel(filename){
  const path = 'modelle/' + filename;
  dbg('Lade Modell: ' + path);

  if(currentModel){
    scene.remove(currentModel);
    currentModel.traverse(c => { if(c.geometry) c.geometry.dispose(); });
    currentModel = null;
  }
  if(testCube){ scene.remove(testCube); testCube=null; }

  return new Promise((resolve,reject)=>{
    loader.load(path,
      (gltf)=>{
        currentModel = gltf.scene;
        currentModel.scale.set(1,1,1);
        scene.add(currentModel);
        dbg('Modell geladen: '+filename);
        try{ fitCameraToObject(camera,currentModel,controls,1.4); } catch(e){ dbg('Warnung FitCamera: '+e.message); }
        resolve(gltf);
      },
      (xhr)=>{ if(xhr && xhr.total){ dbg('Ladefortschritt: '+Math.round(xhr.loaded/xhr.total*100)+'%'); }},
      (err)=>{ dbg('Fehler beim Laden: '+(err.message||err)); if(!testCube){ scene.add(testCube); } reject(err); }
    );
  });
}

// Farbe anwenden
function applyColor(hex){
  if(!currentModel) return;
  currentModel.traverse(child=>{
    if(child.isMesh && child.material){
      if(Array.isArray(child.material)){
        child.material.forEach(m=>{ if(m.color) m.color.set(hex); });
      }else{ if(child.material.color) child.material.color.set(hex); }
      child.material.needsUpdate=true;
    }
  });
  dbg('Farbe angewendet: '+hex);
}

// UI
const modellSelect = document.getElementById('modell');
const farbeSelect = document.getElementById('farbe');
const reloadBtn = document.getElementById('reloadBtn');

modellSelect.addEventListener('change', async (e) => {
  try {
    await loadModel(e.target.value);
    if (currentModel) applyColor(farbeSelect.value);
  } catch (err) {
    dbg('Modellwechsel fehlgeschlagen: ' + err);
  }
});

farbeSelect.addEventListener('change', (e) => {
  if (currentModel) applyColor(e.target.value);
});

reloadBtn.addEventListener('click', async () => {
  try {
    await loadModel(modellSelect.value);
    if (currentModel) applyColor(farbeSelect.value);
  } catch (err) {
    dbg('Neu laden fehlgeschlagen: ' + err);
  }
});

// Animation
const clock = new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const delta = clock.getDelta();
  controls.update(delta);
  renderer.render(scene,camera);
}
animate();

// Resize
window.addEventListener('resize',()=>{
  const w = container.clientWidth;
  const h = Math.max(container.clientHeight,400);
  camera.aspect = w/h;
  camera.updateProjectionMatrix();
  renderer.setSize(w,h);
});

// Erstes Modell laden
loadModel(modellSelect.value).then(()=>applyColor(farbeSelect.value)).catch(err=>dbg('Erster Ladeversuch fehlgeschlagen: '+err));
</script>
</body>
</html>
